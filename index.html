<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Calculates grey level co-occurrence matrix (GLCM) based texture measures (Hall-Beyer (2017) &lt;https://prism.ucalgary.ca/bitstream/handle/1880/51900/texture%20tutorial%20v%203_0%20180206.pdf&gt;; Haralick et al. (1973) &lt;doi:10.1109/TSMC.1973.4309314&gt;) of raster layers using a sliding rectangular window. It also includes functions to quantize a raster into grey levels as well as tabulate a glcm and calculate glcm texture metrics for a matrix.">
<title>GLCM Textures of Raster Layers • GLCMTextures</title>
<script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="GLCM Textures of Raster Layers">
<meta property="og:description" content="Calculates grey level co-occurrence matrix (GLCM) based texture measures (Hall-Beyer (2017) &lt;https://prism.ucalgary.ca/bitstream/handle/1880/51900/texture%20tutorial%20v%203_0%20180206.pdf&gt;; Haralick et al. (1973) &lt;doi:10.1109/TSMC.1973.4309314&gt;) of raster layers using a sliding rectangular window. It also includes functions to quantize a raster into grey levels as well as tabulate a glcm and calculate glcm texture metrics for a matrix.">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="index.html">GLCMTextures</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.7</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="reference/index.html">Reference</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/ailich/GLCMTextures/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-home">
<div class="row">
  <main id="main" class="col-md-9"><div class="section level1">
<div class="page-header"><h1 id="readme">README<a class="anchor" aria-label="anchor" href="#readme"></a>
</h1></div>
<p>Alexander Ilich January 30, 2023</p>
<!-- badges: start -->

<p>Ilich, Alexander R. 2020. “GLCMTextures.”, <a href="https://doi.org/10.5281/zenodo.4310186" class="external-link uri">https://doi.org/10.5281/zenodo.4310186</a>. <a href="https://github.com/ailich/GLCMTextures" class="external-link uri">https://github.com/ailich/GLCMTextures</a>.</p>
</div>
<div class="section level1">
<h1 id="glcmtextures">GLCMTextures<a class="anchor" aria-label="anchor" href="#glcmtextures"></a>
</h1>
<div class="section level2">
<h2 id="purpose">Purpose<a class="anchor" aria-label="anchor" href="#purpose"></a>
</h2>
<p>This R package calculates the most common gray-level co-occurrence matrix (GLCM) texture metrics used for spatial analysis (Hall-Beyer 2017). It interfaces with C++ via the Rcpp and RcppArmadillo packages for increased speed.</p>
<p>Texture metrics are calculated using a symmetric gray level co-occurence matrix (GLCM), meaning that each pixel is counted as a focal and neighboring pixel. For more details on how a symmetric GLCM is constructed, I highly recommend checking out Dr. Mryka Hall-Beyer’s <a href="https://prism.ucalgary.ca/bitstream/handle/1880/51900/texture%20tutorial%20v%203_0%20180206.pdf" class="external-link">GLCM texture tutorial</a>.</p>
</div>
<div class="section level2">
<h2 id="motivation">Motivation<a class="anchor" aria-label="anchor" href="#motivation"></a>
</h2>
<p>When comparing results across different software that calculate GLCM texture metrics, there are inconsistencies among results. This package is meant to provide a clearly documented implementation of GLCM texture metrics that gives the user control over key parameters to make it clear to the user exactly what they are calculating. As such, the formulas for each texture metric are provided, different shifts can be specified, the user can decide how to handle NA values, and the user gets control over how and if the data should be quantized.</p>
</div>
<div class="section level2">
<h2 id="install-and-load-package">Install and Load Package<a class="anchor" aria-label="anchor" href="#install-and-load-package"></a>
</h2>
<p>The package can be installed from CRAN using <code>install.packages("GLCMTextures")</code> or the development version can be installed from github using the code <code>remotes::install_github("ailich/GLCMTextures")</code>. If you are using Windows, you may need to install Rtools using the instructions found <a href="https://cran.r-project.org/bin/windows/Rtools/" class="external-link">here</a>). To install from github you must already have the remotes package installed, which can be installed using <code>install.packages("remotes")</code></p>
<p>This package relies on the <code>terra</code> package for handling of spatial raster data.</p>
</div>
<div class="section level2">
<h2 id="specifying-the-relationship-between-focal-and-neighbor-pixels">Specifying the Relationship Between Focal and Neighbor Pixels<a class="anchor" aria-label="anchor" href="#specifying-the-relationship-between-focal-and-neighbor-pixels"></a>
</h2>
<p>The convention for specifying the direction of the neighboring pixel (the shift) is shown in the image below. The blue pixel in the center is treated as the focal pixel in the example. Shifts are specified as <code>c(x_shift, y_shift)</code>. So, a shift of <code>c(1,0)</code> refers to a the neighboring pixel being 1 to the right and 0 upwards of the focal pixel. Since a symmetric GLCM is created, this means each pixel is counted as both a focal and a neighboring pixel, so it also tabulates the shift in the opposite direction <code>c(-1,0)</code>, which is the dotted blue line. Therefore, these two shifts will produce equivalent results. Although neighboring pixels are typically considered as those one away in a given direction, the shift value can be specified as any integer value.</p>
<div class="figure">
<img src="reference/figures/GLCM_Shift.png" alt=""><p class="caption">GLCM Shift</p>
</div>
</div>
<div class="section level2">
<h2 id="available-metrics">Available Metrics<a class="anchor" aria-label="anchor" href="#available-metrics"></a>
</h2>
<p>There are 8 metrics than can be calculated by this package. These metrics can be divided into 3 groups: the contrast group, the orderliness group, and the descriptive statistics group (Hall-Beyer 2017). The formulas provided below are from Hall-Beyer (2017).</p>
<p>N = Number of rows or columns in the GLCM (Equal to the number of gray levels)</p>
<p>i = row indices of the GLCM matrix (equal to gray level of reference cell)</p>
<p>j = column indices of the GLCM matrix (equal to gray level of neighboring cell)</p>
<p>P<sub>i,j</sub> = Probability (relative frequency) of neighboring cells having gray levels i &amp; j</p>
<div class="section level3">
<h3 id="contrast-group">Contrast Group<a class="anchor" aria-label="anchor" href="#contrast-group"></a>
</h3>
<p><span class="math display">$$\text{GLCM Contrast} = \sum_{i,j=0}^{N-1} {P_{i,j}(i-j)^2}$$</span></p>
<p><span class="math display">$$\text{GLCM Dissimilarity} = \sum_{i,j=0}^{N-1} {P_{i,j}|i-j|}$$</span></p>
<p><span class="math display">$$\text{GLCM Homogeneity} = \sum_{i,j=0}^{N-1} \frac{P_{i,j}}{1+(i-j)^2}$$</span></p>
</div>
<div class="section level3">
<h3 id="orderliness-group">Orderliness Group<a class="anchor" aria-label="anchor" href="#orderliness-group"></a>
</h3>
<p><span class="math display">$$\text{GLCM Angular Second Moment (ASM)} = \sum_{i,j=0}^{N-1} {P_{i,j}^2}$$</span></p>
<p><span class="math display">$$\text{GLCM Entropy} = \sum_{i,j=0}^{N-1} {P_{i,j}[-ln(P_{i,j})]} \text{ where } 0*ln(0)=0$$</span></p>
</div>
<div class="section level3">
<h3 id="descriptive-statistics-group">Descriptive Statistics Group<a class="anchor" aria-label="anchor" href="#descriptive-statistics-group"></a>
</h3>
<p><span class="math display">$$\text{GLCM Mean} (\mu) = \sum_{i,j=0}^{N-1} i(P_{i,j})$$</span></p>
<p><span class="math display">$$\text{GLCM Variance} (\sigma^2) = \sum_{i,j=0}^{N-1} P_{i,j}(i-\mu)^2$$</span></p>
<p><span class="math display">$$\text{GLCM Correlation} = \sum_{i,j=0}^{N-1} {P_{i,j} \frac{(i-\mu)(j-\mu)}{\sigma^2}}$$</span></p>
</div>
</div>
<div class="section level2">
<h2 id="tutorial">Tutorial<a class="anchor" aria-label="anchor" href="#tutorial"></a>
</h2>
<p>Load packages</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ailich.github.io/GLCMTextures/">GLCMTextures</a></span><span class="op">)</span> <span class="co">#Load GLCMTextures package</span></span></code></pre></div>
<p>See package help page</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/help.html" class="external-link">help</a></span><span class="op">(</span>package<span class="op">=</span><span class="st">"GLCMTextures"</span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="test-matrix">Test Matrix<a class="anchor" aria-label="anchor" href="#test-matrix"></a>
</h3>
<p>Before conducting texture calculations on entire raster data sets, we will work with a small matrix.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_matrix</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>data<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">3</span>, ncol<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">test_matrix</span><span class="op">)</span></span>
<span><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span><span class="co">#&gt; [1,]    2    3    0</span></span>
<span><span class="co">#&gt; [2,]    0    0    3</span></span>
<span><span class="co">#&gt; [3,]    1    0    2</span></span></code></pre></div>
<p>This test matrix has 3 rows and 3 columns and contains values from 0-3 (4 gray levels).</p>
<p>We can use the<code>make_glcm</code> function to create a normalized symmetric GLCM.</p>
<p>A GLCM is a tabulation of counts and has the dimensions of the number of gray levels. The GLCM is initialized with all zeros and then we add as we tabulate counts.</p>
<p><strong>Initialzed GLCM</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    0    0    0    0</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    0    0    0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0    0    0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [4,]    0    0    0    0</span></span></code></pre></div>
<p>The row and column number refers to the gray value of the focal and neighboring pixel (Since gray levels start at a value of 0, the row/column number is 1 larger than the corresponding gray level).We will use a shift of <code>c(1,0)</code> meaning that the neighboring pixels is the pixel directly to the right of the focal pixel. We start in the top left corner and we can see that we have a 2 as the focal value and a 3 as the neighboring value directly to the right, so we add 1 to the corresponding position in the GLCM which is row 3 (2+1)/column 4(3+1). Since we would like to create a symmetric GLCM where each pixel is treated as both a focal and neighbor value, we also add to row 4/column 3.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    0    0    0    0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    0    0    0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0    0    1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [4,]    0    0    1    0</span></span></code></pre></div>
<p>We then continue this process throughout the whole image, moving right to the next focal pixel, and down to start the next row when a given row is completed. The resulting GLCM is a square matrix of counts that is symmetric about the diagonal.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">horizontal_glcm</span><span class="op">&lt;-</span> <span class="fu"><a href="reference/make_glcm.html">make_glcm</a></span><span class="op">(</span><span class="va">test_matrix</span>, n_levels <span class="op">=</span> <span class="fl">4</span>, shift <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span>, normalize <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">horizontal_glcm</span></span>
<span><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span><span class="co">#&gt; [1,]    2    1    1    2</span></span>
<span><span class="co">#&gt; [2,]    1    0    0    0</span></span>
<span><span class="co">#&gt; [3,]    1    0    0    1</span></span>
<span><span class="co">#&gt; [4,]    2    0    1    0</span></span></code></pre></div>
<p>Once we have finished tabulating all the counts we “normailize” the GLCM by dividing the each element by the sum of all the counts to get relative frequencies or probabilities that a given pixel of value i occurs next to a pixel of value j. The values in a normalized GLCM will therefore sum to 1.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">horizontal_glcm</span><span class="op">&lt;-</span> <span class="va">horizontal_glcm</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">horizontal_glcm</span><span class="op">)</span></span>
<span><span class="va">horizontal_glcm</span></span>
<span><span class="co">#&gt;            [,1]       [,2]       [,3]       [,4]</span></span>
<span><span class="co">#&gt; [1,] 0.16666667 0.08333333 0.08333333 0.16666667</span></span>
<span><span class="co">#&gt; [2,] 0.08333333 0.00000000 0.00000000 0.00000000</span></span>
<span><span class="co">#&gt; [3,] 0.08333333 0.00000000 0.00000000 0.08333333</span></span>
<span><span class="co">#&gt; [4,] 0.16666667 0.00000000 0.08333333 0.00000000</span></span></code></pre></div>
<p>This could be accomplished in one line of code by setting the argument <code>normalize=TRUE</code> which is the default.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="reference/make_glcm.html">make_glcm</a></span><span class="op">(</span><span class="va">test_matrix</span>, n_levels <span class="op">=</span> <span class="fl">4</span>, shift <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span>, normalize <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;            [,1]       [,2]       [,3]       [,4]</span></span>
<span><span class="co">#&gt; [1,] 0.16666667 0.08333333 0.08333333 0.16666667</span></span>
<span><span class="co">#&gt; [2,] 0.08333333 0.00000000 0.00000000 0.00000000</span></span>
<span><span class="co">#&gt; [3,] 0.08333333 0.00000000 0.00000000 0.08333333</span></span>
<span><span class="co">#&gt; [4,] 0.16666667 0.00000000 0.08333333 0.00000000</span></span></code></pre></div>
<p>You may have noticed that pixels in the last column of the test matrix did not have a neighboring pixel to the right, so you would not tabulate any counts in those cases; however, this is precisely why we tabulate a symmetrical GLCM as these pixels do have neighbors to the left. Also, note that although the original matrix was 3x3, the GLCM is 4x4 because the size of the GLCM corresponds to the number of gray levels, not the size of the input matrix.</p>
<p>Once the GLCM has been constructed, we can use this to calculate texture metrics using the<code>glcm_metrics</code> function to calculate the GLCM texture metrics</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="reference/glcm_metrics.html">glcm_metrics</a></span><span class="op">(</span><span class="va">horizontal_glcm</span><span class="op">)</span></span>
<span><span class="co">#&gt;      glcm_contrast glcm_dissimilarity   glcm_homogeneity           glcm_ASM </span></span>
<span><span class="co">#&gt;           4.000000           1.666667           0.400000           0.125000 </span></span>
<span><span class="co">#&gt;       glcm_entropy          glcm_mean      glcm_variance   glcm_correlation </span></span>
<span><span class="co">#&gt;           2.138333           1.166667           1.638889          -0.220339</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="raster-data">Raster Data<a class="anchor" aria-label="anchor" href="#raster-data"></a>
</h3>
<p>Now we can move from calculating a single value of a given texture metric to calculating raster surfaces of texture metrics.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">r</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html" class="external-link">rast</a></span><span class="op">(</span><span class="va">volcano</span>, extent<span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/ext.html" class="external-link">ext</a></span><span class="op">(</span><span class="fl">2667400</span>, <span class="fl">2667400</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/dimensions.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">volcano</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span>, <span class="fl">6478700</span>, <span class="fl">6478700</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/dimensions.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">volcano</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span><span class="op">)</span>, crs <span class="op">=</span> <span class="st">"EPSG:27200"</span><span class="op">)</span> <span class="co">#Use preloaded volcano dataset as a raster</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span> <span class="co">#plot values</span></span></code></pre></div>
<p><img src="reference/figures/README-unnamed-chunk-10-1.png" width="100%"></p>
<div class="section level4">
<h4 id="raster-quantization">Raster Quantization<a class="anchor" aria-label="anchor" href="#raster-quantization"></a>
</h4>
<p>Our test image had integer values that range from 0 to 3. Raster data often represent continuous data that cover a potentially large range and may not be confined to integer values greater than or equal to zero. The first step is therefore to quantize the raster image to a discrete number of gray levels. This can be done using the<code>quantize_raster</code> function. Typically data are quantized to 16 (4 bit; 2<sup>4</sup>) or 32 (5 bit; 2<sup>5</sup>) gray levels. With increasing number of gray levels, the computation cost increases.</p>
<p>There are two methods of quantization available in the <code>quantize_raster</code> function. The first way, <code>method = "equal range"</code>, will create bins that cover a range of equal size (e.g. if the original data ranged from 0-20 and was quantized to 4 levels, [0-5) would be reassigned to 0, [5-10) would be reassigned to 1, [10-15) would be reassigned to 2, and [15-20] would be reassigned to 4). This is the simplest and most common quantization method. By default the raster is scaled using the min and max of the data set, but a max and min value can be supplied to the <code>max_val</code> and <code>min_val</code> parameters. This may be more desirable if making comparisons across several different rasters where you need the gray levels to correspond in a consistent way to the original data, as you can supply the global max/min or the theoretical max/min values that could occur.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rq_equalrange</span><span class="op">&lt;-</span> <span class="fu"><a href="reference/quantize_raster.html">quantize_raster</a></span><span class="op">(</span>r <span class="op">=</span> <span class="va">r</span>, n_levels <span class="op">=</span> <span class="fl">16</span>, method <span class="op">=</span> <span class="st">"equal range"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">rq_equalrange</span>, col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/gray.colors.html" class="external-link">grey.colors</a></span><span class="op">(</span><span class="fl">16</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="reference/figures/README-unnamed-chunk-11-1.png" width="100%"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] "Min Val = 0"</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] "Max Val = 15"</span></span></code></pre></div>
<p>The second way to perform quantization is <code>method = "equal prob"</code> which performs equal probability quantization and will use quantiles (Hyndman and Fan 1996) to create bins that contain an approximately equal number of samples. This is the quantization method suggested in the original paper (Haralick and Shanmugam 1973).</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rq_equalprob</span><span class="op">&lt;-</span> <span class="fu"><a href="reference/quantize_raster.html">quantize_raster</a></span><span class="op">(</span>r <span class="op">=</span> <span class="va">r</span>, n_levels <span class="op">=</span> <span class="fl">16</span>, method <span class="op">=</span> <span class="st">"equal prob"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">rq_equalprob</span>, col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/gray.colors.html" class="external-link">grey.colors</a></span><span class="op">(</span><span class="fl">16</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="reference/figures/README-unnamed-chunk-13-1.png" width="100%"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] "Min Val = 0"</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] "Max Val = 15"</span></span></code></pre></div>
<p>Since we used equal probability quantization, each value has approximately the same count</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/freq.html" class="external-link">freq</a></span><span class="op">(</span><span class="va">rq_equalprob</span><span class="op">)</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"value"</span>, <span class="st">"count"</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#&gt;    value count</span></span>
<span><span class="co">#&gt; 1      0   304</span></span>
<span><span class="co">#&gt; 2      1   344</span></span>
<span><span class="co">#&gt; 3      2   269</span></span>
<span><span class="co">#&gt; 4      3   313</span></span>
<span><span class="co">#&gt; 5      4   394</span></span>
<span><span class="co">#&gt; 6      5   302</span></span>
<span><span class="co">#&gt; 7      6   340</span></span>
<span><span class="co">#&gt; 8      7   354</span></span>
<span><span class="co">#&gt; 9      8   332</span></span>
<span><span class="co">#&gt; 10     9   342</span></span>
<span><span class="co">#&gt; 11    10   341</span></span>
<span><span class="co">#&gt; 12    11   330</span></span>
<span><span class="co">#&gt; 13    12   321</span></span>
<span><span class="co">#&gt; 14    13   323</span></span>
<span><span class="co">#&gt; 15    14   339</span></span>
<span><span class="co">#&gt; 16    15   359</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="calculate-texture-metrics-raster-surfaces">Calculate Texture Metrics Raster Surfaces<a class="anchor" aria-label="anchor" href="#calculate-texture-metrics-raster-surfaces"></a>
</h4>
<p>For raster data sets, rather than calculating a single value of the texture for the entire image, we create a surface that represents the texture in a given neighborhood around each pixel. To do this we calculate texture metrics using a rectangular <a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-focal-statistics-works.htm" class="external-link">sliding window of a given size</a>. We start at the top left pixel and treat that as the central pixel, and specify a window of given dimensions. We then extract a window of that size around the central pixel (note: window size must be odd). This extracted window is then run through the process shown before for test_matrix, and the resulting value of a texture metric is assigned as the value for the position corresponding with the central pixel. To do this, we can use the<code>glcm_textures</code> function.</p>
<p>For example, below we calculate textures using a window size of 3 rows by 5 columns</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">textures1</span><span class="op">&lt;-</span> <span class="fu"><a href="reference/glcm_textures.html">glcm_textures</a></span><span class="op">(</span><span class="va">rq_equalprob</span>, w <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">)</span>, n_levels <span class="op">=</span> <span class="fl">16</span>, quantization <span class="op">=</span> <span class="st">"none"</span>, shift <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">textures1</span><span class="op">)</span></span></code></pre></div>
<p><img src="reference/figures/README-unnamed-chunk-16-1.png" width="100%"></p>
<p>You may have noticed in the example above that <code>quantization = "none"</code>. This is because we supplied a raster that was already quantized.</p>
<p>We could instead call the original raster and have it quantized within the <code>glcm_textures</code> function.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">textures2</span><span class="op">&lt;-</span> <span class="fu"><a href="reference/glcm_textures.html">glcm_textures</a></span><span class="op">(</span><span class="va">r</span>, w <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">)</span>, n_levels <span class="op">=</span> <span class="fl">16</span>, quantization <span class="op">=</span> <span class="st">"equal prob"</span>, shift<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/values.html" class="external-link">values</a></span><span class="op">(</span><span class="va">textures1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/pkg/terra/man/values.html" class="external-link">values</a></span><span class="op">(</span><span class="va">textures2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>We can also calculate the value of textures across multiple shifts by supplying a list. In fact, the default is to return directionally/rotationally invariant textures that are averaged across all 4 directions <code>shift = list(c(1, 0), c(1, 1), c(0, 1), c(-1, 1))</code>.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">textures3</span><span class="op">&lt;-</span> <span class="fu"><a href="reference/glcm_textures.html">glcm_textures</a></span><span class="op">(</span><span class="va">r</span>, w <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">)</span>, n_levels <span class="op">=</span> <span class="fl">16</span>, quantization <span class="op">=</span> <span class="st">"equal prob"</span>, shift <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">textures3</span><span class="op">)</span></span></code></pre></div>
<p><img src="reference/figures/README-unnamed-chunk-18-1.png" width="100%"></p>
<p><strong>Some Other Options</strong></p>
<p>By default all calculated texture metrics are returned; however you can have only a subset returned by specifying which ones you want using the <code>metrics</code> argument.</p>
<p>You can also use <code>na.rm</code> to specify how you want to handle <code>NA</code> values.</p>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h1>
<p><a href="https://prism.ucalgary.ca/bitstream/handle/1880/51900/texture%20tutorial%20v%203_0%20180206.pdf" class="external-link">Hall-Beyer, Mryka. 2017. “GLCM Texture Tutorial v3.0.</a></p>
<p>Haralick, Robert M, Karthikeyan Shanmugam, and Its’Hak Dinstein. 1973. “Textural features for image classification.” IEEE Transactions on systems, man, and cybernetics (6):610-621.</p>
<p>Hyndman, Rob J, and Yanan Fan. 1996. “Sample quantiles in statistical packages.” The American Statistician 50 (4):361-365.</p>
</div>

  </main><aside class="col-md-3"><div class="links">
<h2 data-toc-skip>Links</h2>
<ul class="list-unstyled">
<li><a href="https://cloud.r-project.org/package=GLCMTextures" class="external-link">View on CRAN</a></li>
<li><a href="https://github.com/ailich/GLCMTextures/" class="external-link">Browse source code</a></li>
<li><a href="https://github.com/ailich/GLCMTextures/issues" class="external-link">Report a bug</a></li>
</ul>
</div>

<div class="license">
<h2 data-toc-skip>License</h2>
<ul class="list-unstyled">
<li><a href="LICENSE.html">Full license</a></li>
<li><small>GPL (&gt;= 3)</small></li>
</ul>
</div>


<div class="citation">
<h2 data-toc-skip>Citation</h2>
<ul class="list-unstyled">
<li><a href="authors.html#citation">Citing GLCMTextures</a></li>
</ul>
</div>

<div class="developers">
<h2 data-toc-skip>Developers</h2>
<ul class="list-unstyled">
<li>Alexander Ilich <br><small class="roles"> Author, maintainer </small> <a href="https://orcid.org/0000-0003-1758-8499" target="orcid.widget" aria-label="ORCID" class="external-link"><span class="fab fa-orcid orcid" aria-hidden="true"></span></a> </li>
</ul>
</div>

<div class="dev-status">
<h2 data-toc-skip>Dev status</h2>
<ul class="list-unstyled">
<li><a href="https://github.com/ailich/GLCMTextures/actions/workflows/R-CMD-check.yaml" class="external-link"><img src="https://github.com/ailich/GLCMTextures/actions/workflows/R-CMD-check.yaml/badge.svg" alt="R-CMD-check"></a></li>
<li><a href="https://cran.r-project.org/package=GLCMTextures" class="external-link"><img src="https://www.r-pkg.org/badges/version/GLCMTextures" alt="CRAN"></a></li>
<li><a href="https://www.gnu.org/licenses/gpl-3.0" class="external-link"><img src="https://img.shields.io/badge/License-GPLv3-blue.svg" alt="License: GPLv3"></a></li>
<li><a href="https://zenodo.org/badge/latestdoi/299630902" class="external-link"><img src="https://zenodo.org/badge/299630902.svg" alt="DOI"></a></li>
</ul>
</div>

  </aside>
</div>


    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Alexander Ilich.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
